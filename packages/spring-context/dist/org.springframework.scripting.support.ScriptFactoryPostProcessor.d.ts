declare namespace org {
    namespace springframework {
        namespace scripting {
            namespace support {
                /**
                 * {@link org.springframework.beans.factory.config.BeanPostProcessor} that
                 * handles {@link org.springframework.scripting.ScriptFactory} definitions,
                 * replacing each factory with the actual scripted Java object generated by it.
                 * <p>This is similar to the
                 * {@link org.springframework.beans.factory.FactoryBean} mechanism, but is
                 * specifically tailored for scripts and not built into Spring's core
                 * container itself but rather implemented as an extension.
                 * <p><b>NOTE:</b> The most important characteristic of this post-processor
                 * is that constructor arguments are applied to the
                 * {@link org.springframework.scripting.ScriptFactory} instance
                 * while bean property values are applied to the generated scripted object.
                 * Typically, constructor arguments include a script source locator and
                 * potentially script interfaces, while bean property values include
                 * references and config values to inject into the scripted object itself.
                 * <p>The following {@link ScriptFactoryPostProcessor} will automatically
                 * be applied to the two
                 * {@link org.springframework.scripting.ScriptFactory} definitions below.
                 * At runtime, the actual scripted objects will be exposed for
                 * "bshMessenger" and "groovyMessenger", rather than the
                 * {@link org.springframework.scripting.ScriptFactory} instances. Both of
                 * those are supposed to be castable to the example's {@code Messenger}
                 * interfaces here.
                 * <pre class="code">&lt;bean class="org.springframework.scripting.support.ScriptFactoryPostProcessor"/&gt;
                 * &lt;bean id="bshMessenger" class="org.springframework.scripting.bsh.BshScriptFactory"&gt;
                 * &lt;constructor-arg value="classpath:mypackage/Messenger.bsh"/&gt;
                 * &lt;constructor-arg value="mypackage.Messenger"/&gt;
                 * &lt;property name="message" value="Hello World!"/&gt;
                 * &lt;/bean&gt;
                 * &lt;bean id="groovyMessenger" class="org.springframework.scripting.groovy.GroovyScriptFactory"&gt;
                 * &lt;constructor-arg value="classpath:mypackage/Messenger.groovy"/&gt;
                 * &lt;property name="message" value="Hello World!"/&gt;
                 * &lt;/bean&gt;</pre>
                 * <p><b>NOTE:</b> Please note that the above excerpt from a Spring
                 * XML bean definition file uses just the &lt;bean/&gt;-style syntax
                 * (in an effort to illustrate using the {@link ScriptFactoryPostProcessor} itself).
                 * In reality, you would never create a &lt;bean/&gt; definition for a
                 * {@link ScriptFactoryPostProcessor} explicitly; rather you would import the
                 * tags from the {@code 'lang'} namespace and simply create scripted
                 * beans using the tags in that namespace... as part of doing so, a
                 * {@link ScriptFactoryPostProcessor} will implicitly be created for you.
                 * <p>The Spring reference documentation contains numerous examples of using
                 * tags in the {@code 'lang'} namespace; by way of an example, find below
                 * a Groovy-backed bean defined using the {@code 'lang:groovy'} tag.
                 * <pre class="code">
                 * &lt;?xml version="1.0" encoding="UTF-8"?&gt;
                 * &lt;beans xmlns="http://www.springframework.org/schema/beans"
                 * xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 * xmlns:lang="http://www.springframework.org/schema/lang"&gt;
                 * &lt;!-- this is the bean definition for the Groovy-backed Messenger implementation --&gt;
                 * &lt;lang:groovy id="messenger" script-source="classpath:Messenger.groovy"&gt;
                 * &lt;lang:property name="message" value="I Can Do The Frug" /&gt;
                 * &lt;/lang:groovy&gt;
                 * &lt;!-- an otherwise normal bean that will be injected by the Groovy-backed Messenger --&gt;
                 * &lt;bean id="bookingService" class="x.y.DefaultBookingService"&gt;
                 * &lt;property name="messenger" ref="messenger" /&gt;
                 * &lt;/bean&gt;
                 * &lt;/beans&gt;</pre>
                 * @author Juergen Hoeller
                 * @author Rob Harrop
                 * @author Rick Evans
                 * @author Mark Fisher
                 * @since 2.0
                 */
                // @ts-ignore
                class ScriptFactoryPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements org.springframework.context.ResourceLoaderAware {
                    // @ts-ignore
                    constructor()
                    /**
                     * The {@link org.springframework.core.io.Resource}-style prefix that denotes
                     * an inline script.
                     * <p>An inline script is a script that is defined right there in the (typically XML)
                     * configuration, as opposed to being defined in an external file.
                     */
                    // @ts-ignore
                    readonly INLINE_SCRIPT_PREFIX: string
                    /**
                     * The {@code refreshCheckDelay} attribute.
                     */
                    // @ts-ignore
                    readonly REFRESH_CHECK_DELAY_ATTRIBUTE: string
                    /**
                     * The {@code proxyTargetClass} attribute.
                     */
                    // @ts-ignore
                    readonly PROXY_TARGET_CLASS_ATTRIBUTE: string
                    /**
                     * The {@code language} attribute.
                     */
                    // @ts-ignore
                    readonly LANGUAGE_ATTRIBUTE: string
                    /**
                     * Logger available to subclasses.
                     */
                    // @ts-ignore
                    readonly logger: Log
                    /**
                     * Set the delay between refresh checks, in milliseconds.
                     * Default is -1, indicating no refresh checks at all.
                     * <p>Note that an actual refresh will only happen when
                     * the {@link org.springframework.scripting.ScriptSource} indicates
                     * that it has been modified.
                     * @see org.springframework.scripting.ScriptSource#isModified()
                     */
                    // @ts-ignore
                    setDefaultRefreshCheckDelay(defaultRefreshCheckDelay: number /*long*/): void
                    /**
                     * Flag to signal that refreshable proxies should be created to proxy the target class not its interfaces.
                     * @param defaultProxyTargetClass the flag value to set
                     */
                    // @ts-ignore
                    setDefaultProxyTargetClass(defaultProxyTargetClass: boolean): void
                    // @ts-ignore
                    setBeanClassLoader(classLoader: java.lang.ClassLoader): void
                    // @ts-ignore
                    setBeanFactory(beanFactory: BeanFactory): void
                    // @ts-ignore
                    setResourceLoader(resourceLoader: ResourceLoader): void
                    // @ts-ignore
                    getOrder(): int
                    // @ts-ignore
                    predictBeanType(beanClass: java.lang.Class<any>, beanName: string): java.lang.Class<?>
                    // @ts-ignore
                    postProcessProperties(pvs: PropertyValues, bean: any, beanName: string): PropertyValues
                    // @ts-ignore
                    postProcessBeforeInstantiation(beanClass: java.lang.Class<any>, beanName: string): java.lang.Object
                    /**
                     * Prepare the script beans in the internal BeanFactory that this
                     * post-processor uses. Each original bean definition will be split
                     * into a ScriptFactory definition and a scripted object definition.
                     * @param bd the original bean definition in the main BeanFactory
                     * @param scriptFactoryBeanName the name of the internal ScriptFactory bean
                     * @param scriptedObjectBeanName the name of the internal scripted object bean
                     */
                    // @ts-ignore
                    prepareScriptBeans(bd: BeanDefinition, scriptFactoryBeanName: string, scriptedObjectBeanName: string): void
                    /**
                     * Get the refresh check delay for the given {@link ScriptFactory} {@link BeanDefinition}.
                     * If the {@link BeanDefinition} has a
                     * {@link org.springframework.core.AttributeAccessor metadata attribute}
                     * under the key {@link #REFRESH_CHECK_DELAY_ATTRIBUTE} which is a valid {@link Number}
                     * type, then this value is used. Otherwise, the {@link #defaultRefreshCheckDelay}
                     * value is used.
                     * @param beanDefinition the BeanDefinition to check
                     * @return the refresh check delay
                     */
                    // @ts-ignore
                    resolveRefreshCheckDelay(beanDefinition: BeanDefinition): long
                    // @ts-ignore
                    resolveProxyTargetClass(beanDefinition: BeanDefinition): boolean
                    /**
                     * Create a ScriptFactory bean definition based on the given script definition,
                     * extracting only the definition data that is relevant for the ScriptFactory
                     * (that is, only bean class and constructor arguments).
                     * @param bd the full script bean definition
                     * @return the extracted ScriptFactory bean definition
                     * @see org.springframework.scripting.ScriptFactory
                     */
                    // @ts-ignore
                    createScriptFactoryBeanDefinition(bd: BeanDefinition): BeanDefinition
                    /**
                     * Obtain a ScriptSource for the given bean, lazily creating it
                     * if not cached already.
                     * @param beanName the name of the scripted bean
                     * @param scriptSourceLocator the script source locator associated with the bean
                     * @return the corresponding ScriptSource instance
                     * @see #convertToScriptSource
                     */
                    // @ts-ignore
                    getScriptSource(beanName: string, scriptSourceLocator: string): org.springframework.scripting.ScriptSource
                    /**
                     * Convert the given script source locator to a ScriptSource instance.
                     * <p>By default, supported locators are Spring resource locations
                     * (such as "file:C:/myScript.bsh" or "classpath:myPackage/myScript.bsh")
                     * and inline scripts ("inline:myScriptText...").
                     * @param beanName the name of the scripted bean
                     * @param scriptSourceLocator the script source locator
                     * @param resourceLoader the ResourceLoader to use (if necessary)
                     * @return the ScriptSource instance
                     */
                    // @ts-ignore
                    convertToScriptSource(beanName: string, scriptSourceLocator: string, resourceLoader: ResourceLoader): org.springframework.scripting.ScriptSource
                    /**
                     * Create a config interface for the given bean definition, defining setter
                     * methods for the defined property values as well as an init method and
                     * a destroy method (if defined).
                     * <p>This implementation creates the interface via CGLIB's InterfaceMaker,
                     * determining the property types from the given interfaces (as far as possible).
                     * @param bd the bean definition (property values etc) to create a
                     *  config interface for
                     * @param interfaces the interfaces to check against (might define
                     *  getters corresponding to the setters we're supposed to generate)
                     * @return the config interface
                     * @see org.springframework.cglib.proxy.InterfaceMaker
                     * @see org.springframework.beans.BeanUtils#findPropertyType
                     */
                    // @ts-ignore
                    createConfigInterface(bd: BeanDefinition, interfaces: java.lang.Class[]): java.lang.Class<?>
                    /**
                     * Create a composite interface Class for the given interfaces,
                     * implementing the given interfaces in one single Class.
                     * <p>The default implementation builds a JDK proxy class
                     * for the given interfaces.
                     * @param interfaces the interfaces to merge
                     * @return the merged interface as Class
                     * @see java.lang.reflect.Proxy#getProxyClass
                     */
                    // @ts-ignore
                    createCompositeInterface(interfaces: java.lang.Class[]): java.lang.Class<?>
                    /**
                     * Create a bean definition for the scripted object, based on the given script
                     * definition, extracting the definition data that is relevant for the scripted
                     * object (that is, everything but bean class and constructor arguments).
                     * @param bd the full script bean definition
                     * @param scriptFactoryBeanName the name of the internal ScriptFactory bean
                     * @param scriptSource the ScriptSource for the scripted bean
                     * @param interfaces the interfaces that the scripted bean is supposed to implement
                     * @return the extracted ScriptFactory bean definition
                     * @see org.springframework.scripting.ScriptFactory#getScriptedObject
                     */
                    // @ts-ignore
                    createScriptedObjectBeanDefinition(bd: BeanDefinition, scriptFactoryBeanName: string, scriptSource: org.springframework.scripting.ScriptSource, interfaces: java.lang.Class[]): BeanDefinition
                    /**
                     * Create a refreshable proxy for the given AOP TargetSource.
                     * @param ts the refreshable TargetSource
                     * @param interfaces the proxy interfaces (may be {#code null} to
                     *  indicate proxying of all interfaces implemented by the target class)
                     * @return the generated proxy
                     * @see RefreshableScriptTargetSource
                     */
                    // @ts-ignore
                    createRefreshableProxy(ts: TargetSource, interfaces: java.lang.Class[], proxyTargetClass: boolean): java.lang.Object
                    /**
                     * Destroy the inner bean factory (used for scripts) on shutdown.
                     */
                    // @ts-ignore
                    destroy(): void
                }
            }
        }
    }
}
