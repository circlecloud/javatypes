declare namespace javax {
    namespace net {
        namespace ssl {
            namespace SSLEngineResult {
                /**
                 * An <code>SSLEngineResult</code> enum describing the current
                 * handshaking state of this <code>SSLEngine</code>.
                 * @author Brad R. Wetmore
                 * @since 1.5
                 */
                // @ts-ignore
                class HandshakeStatus extends java.lang.Enum<javax.net.ssl.SSLEngineResult.HandshakeStatus> {
                    /**
                     * The <code>SSLEngine</code> is not currently handshaking.
                     */
                    // @ts-ignore
                    public static readonly NOT_HANDSHAKING: javax.net.ssl.SSLEngineResult.HandshakeStatus
                    /**
                     * The <code>SSLEngine</code> has just finished handshaking.
                     * <P>
                     * This value is only generated by a call to
                     * <code>SSLEngine.wrap()/unwrap()</code> when that call
                     * finishes a handshake.  It is never generated by
                     * <code>SSLEngine.getHandshakeStatus()</code>.
                     * @see SSLEngine#wrap(ByteBuffer, ByteBuffer)
                     * @see SSLEngine#unwrap(ByteBuffer, ByteBuffer)
                     * @see SSLEngine#getHandshakeStatus()
                     */
                    // @ts-ignore
                    public static readonly FINISHED: javax.net.ssl.SSLEngineResult.HandshakeStatus
                    /**
                     * The <code>SSLEngine</code> needs the results of one (or more)
                     * delegated tasks before handshaking can continue.
                     * @see SSLEngine#getDelegatedTask()
                     */
                    // @ts-ignore
                    public static readonly NEED_TASK: javax.net.ssl.SSLEngineResult.HandshakeStatus
                    /**
                     * The <code>SSLEngine</code> must send data to the remote side
                     * before handshaking can continue, so <code>SSLEngine.wrap()</code>
                     * should be called.
                     * @see SSLEngine#wrap(ByteBuffer, ByteBuffer)
                     */
                    // @ts-ignore
                    public static readonly NEED_WRAP: javax.net.ssl.SSLEngineResult.HandshakeStatus
                    /**
                     * The <code>SSLEngine</code> needs to receive data from the
                     * remote side before handshaking can continue.
                     */
                    // @ts-ignore
                    public static readonly NEED_UNWRAP: javax.net.ssl.SSLEngineResult.HandshakeStatus
                    // @ts-ignore
                    public static values(): javax.net.ssl.SSLEngineResult.HandshakeStatus[]
                    // @ts-ignore
                    public static valueOf(name: java.lang.String | string): javax.net.ssl.SSLEngineResult.HandshakeStatus
                }
            }
        }
    }
}
